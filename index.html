<!DOCTYPE html>
<html>

<head>
    <title>Three.js Project with Navbar</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: system-ui, -apple-system, sans-serif;
        }

        .navbar {
            position: fixed;
            top: 0;
            width: 100%;
            background-color: #1a1a1a;
            padding: 12px;
            z-index: 11;
            display: flex;
            gap: 20px;
            border-bottom: 1px solid #333;
        }

        .navbar button,
        .navbar .dropdown {
            background: none;
            border: none;
            color: #e1e1e1;
            padding: 10px 15px;
            cursor: pointer;
            font-size: 14px;
            border-radius: 4px;
            transition: all 0.2s ease;
        }

        .navbar button:hover,
        .navbar .dropdown:hover {
            background-color: #333;
        }

        .dropdown {
            position: relative;
            display: inline-block;
        }

        .dropbtn {
            background-color: #1a1a1a;
            color: #e1e1e1;
            padding: 10px 15px;
            font-size: 14px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .dropdown-content {
            display: none;
            position: absolute;
            background-color: #1a1a1a;
            min-width: 180px;
            border-radius: 6px;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);
            z-index: 20;
            border: 1px solid #333;
        }

        .dropdown:hover>.dropdown-content {
            display: block;
        }

        .dropbtn:hover,
        .dropdown:hover>.dropbtn {
            background-color: #333;
        }

        .dropdown-content a,
        .dropdown-content span,
        .dropdown-content button {
            color: #e1e1e1;
            padding: 12px 16px;
            text-decoration: none;
            display: block;
            width: 100%;
            text-align: left;
            background: none;
            border: none;
            font-size: 14px;
            cursor: pointer;
        }

        .dropdown-content a:hover,
        .dropdown-content button:hover {
            background-color: #333;
        }
/*future me remove this*/
        .navbar {
            position: fixed;
            top: 0;
            width: 100%;
            background-color: #1a1a1a;
            padding: 12px;
            z-index: 11;
            display: flex;
            gap: 20px;
            border-bottom: 1px solid #333;
        }

        .dropdown-content .dropdown {
            width: 100%;
        }

        .dropdown-content .dropdown-content {
            left: 100%;
            top: 0;
            margin-top: 0;
        }

        #canvas-container {
            position: fixed;
            top: 50px;
            width: 100%;
            height: calc(100vh - 50px);
            background-color: #141414;
        }

        .tools {
            position: fixed;
            top: 100px;
            left: 10px;
            z-index: 10;
            background: #1a1a1a;
            padding: 8px;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            gap: 4px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            border: 1px solid #333;
        }

        .tools button {
            width: 40px;
            height: 40px;
            padding: 8px;
            background: #262626;
            border: 1px solid #333;
            border-radius: 6px;
            color: #e1e1e1;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }

        .tools button:hover {
            background: #333;
        }

        .tools button.active {
            background: #2563eb;
            border-color: #3b82f6;
        }

        .tools button svg {
            width: 20px;
            height: 20px;
            stroke: currentColor;
            fill: none;
            stroke-width: 2;
            stroke-linecap: round;
            stroke-linejoin: round;
        }

        .stats-panel {
            position: fixed;
            bottom: 60px;
            right: 10px;
            padding: 16px;
            color: #e1e1e1;
            font-size: 14px;
            min-width: 200px;
            z-index: 4;
        }

        .stats-panel h3 {
            margin-bottom: 12px;
            color: #3b82f6;
            font-size: 16px;
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
        }

        .stat-label {
            color: #a1a1a1;
        }

        .stat-value {
            font-family: monospace;
            color: #e1e1e1;
        }

        /* Popup background overlay */
        .popup-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            display: none;
            /* Keep this as single display property */
        }

        .popup-content {
            background: white;
            padding: 20px;
            border-radius: 8px;
            width: 80%;
            max-width: 680px;
            /* 3*200px + 2*20px gaps + padding */
            max-height: 60vh;
            overflow-y: auto;
        }

        .grid-container {
            display: grid;
            grid-template-columns: repeat(3, 200px);
            gap: 20px;
            padding: 20px;
            justify-content: center;
            justify-items: center;
        }

        .selectBox {
            border: 1px solid #55aaff;
            background-color: rgba(75, 160, 255, 0.3);
            position: fixed;
            pointer-events: none;
            z-index: 1001;
            /* Higher than the tools panel's z-index */
        }

        .grid-item {
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 10px;
            text-align: center;
            /* Fixed width */
        }

        .grid-item-2 {
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 10px;
            text-align: center;
            width: 150px;
        }

        .preview-container {
            width: 200px;
            /* Updated from 200px */
            height: 84px;
            position: relative;
            overflow: hidden;
            margin: 0 auto;
        }

        /* Rest of your existing styles remain the same */
        .search-input {
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 5px;
        }

        .add-button {
            margin-top: 10px;
            padding: 8px 16px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        .close-button {
            background: #ff4d4d;
            color: white;
            padding: 5px 10px;
            border: none;
            cursor: pointer;
            align-self: flex-end;
            border-radius: 5px;
        }

        .preview-scene {
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        #characterPopup {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1001;
            /* Higher than other popups */
        }

        .character-popup-content {
            background: white;
            padding: 20px;
            border-radius: 8px;
            width: 80%;
            height: 80%;
            display: flex;
            position: relative;
        }

        .close-btn {
            position: absolute;
            top: 15px;
            right: 15px;
            background: transparent;
            border: none;
            font-size: 24px;
            cursor: pointer;
        }

        .preview-pane {
            position: relative;
            border-right: 2px solid #444;
        }

        #playerPreviewCanvas {
            width: 100%;
            height: 100%;
        }

        .color-picker {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
        }

        .color-input {
            margin: 5px;
        }

        .category-tabs {
            display: flex;
            gap: 5px;
            padding: 10px;
        }

        .tab {
            padding: 5px 10px;
            cursor: pointer;
            background: #333;
        }

        .tab.active {
            background: #555;
        }

        .grid-container {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
            gap: 10px;
            padding: 10px;
            overflow-y: auto;
            max-height: 60vh;
        }


        .item-preview {
            height: 100px;
            /* Fixed preview size */
            overflow: hidden;
        }
    </style>
</head>

<body>
    <!-- Navbar -->
    <nav class="navbar">
        <!-- File dropdown -->
        <div class="dropdown">
            <button class="dropbtn">File</button>
            <div class="dropdown-content">
                <button onclick="handleNew()">New</button>
                <button onclick="handleOpen()">Open</button>
                <button onclick="handleSave()">Save</button>
                <button onclick="handleExport()">Export</button>
            </div>
        </div>

        <div class="dropdown">
            <button class="dropbtn">Add</button>
            <div class="dropdown-content">
                <button onclick="createNewPlayer()">Create Player</button> <!-- Changed from addPlayer -->
                <button onclick="addLevel()">Level</button>
                <button onclick="addPlayer()">Player</button>
                <button onclick="addItem()">Item</button>
                <!--perhaps a search scene function to let the users go to an object -->
            </div>
        </div>


        <div class="dropdown">
            <button class="dropbtn">Import</button>
            <div class="dropdown-content">
                <button onclick="document.getElementById('sgm-file-input').click()">Import .sgm</button>
                <input type="file" id="sgm-file-input" accept=".sgm" style="display:none;"
                    onchange="handleFileSelection(event)" />

                <button onclick="document.getElementById('glb-file-input').click()">Import .glb</button>
                <input type="file" id="glb-file-input" accept=".glb" style="display:none;"
                    onchange="handleFileSelection(event)" />

                <button onclick="document.getElementById('obj-file-input').click()">Import .obj</button>
                <input type="file" id="obj-file-input" accept=".obj" style="display:none;"
                    onchange="handleFileSelection(event)" />
            </div>
        </div>


        <button onclick="handleSettings()">Settings</button>
        <div class="dropdown">
            <button class="dropbtn">Help</button>

            <div class="dropdown-content">
                <div class="dropdown">
                    <button class="dropbtn">Thanks!</button>
                    <div class="dropdown-content">
                        <span>Index</span>
                        <span>Slin</span>
                        <span>Vestria</span>
                    </div>
                </div>

            </div>
        </div>
    </nav>

    <div id="characterPopup">
        <div class="character-popup-content">
            <!-- Left Side - Player Preview -->
            <div class="preview-pane" style="flex: 1; position: relative;">
                <canvas id="playerPreviewCanvas"></canvas>
                <div class="color-picker">
                    <input type="color" id="primaryColor" class="color-input">
                    <input type="color" id="secondaryColor" class="color-input">
                    <button onclick="applyColors()">Apply Colors</button>
                </div>
            </div>

            <!-- Right Side - Equipment Grid -->
            <div class="equipment-grid" style="flex: 1">
                <div class="category-tabs">
                    <button class="tab active" onclick="changeCategory('head')">Head</button>
                    <button class="tab" onclick="changeCategory('body')">Body</button>
                    <button class="tab" onclick="changeCategory('hand')">Hands</button>
                </div>
                <div id="equipmentGrid" class="grid-container"></div>
            </div>
            <button class="close-btn" onclick="closeCharacterPopup()">×</button>
        </div>
    </div>

    <div class="tools" id="tools">
        <button onclick="setTransformMode('translate')" id="translateBtn" title="Move (G)">
            <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <!-- Main arrows -->
                <path d="M12 2v20M12 2l3 3M12 2l-3 3" stroke="currentColor" stroke-width="2" fill="none" />
                <path d="M2 12h20M22 12l-3 3M22 12l-3-3" stroke="currentColor" stroke-width="2" fill="none" />
                <!-- Small arrow indicators -->
                <circle cx="12" cy="12" r="1" fill="currentColor" />
                <path d="M12 22l3-3M12 22l-3-3" stroke="currentColor" stroke-width="2" fill="none" />
                <path d="M2 12l3 3M2 12l3-3" stroke="currentColor" stroke-width="2" fill="none" />
            </svg>
        </button>
        <button onclick="setTransformMode('rotate')" id="rotateBtn" title="Rotate (R)">
            <svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="6.18 5.18 11.63 12.63">
                <path
                    d="M15.7733 13.3292C15.4851 14.1471 14.9388 14.8493 14.2169 15.3298C13.4949 15.8103 12.6363 16.0432 11.7704 15.9934C10.9046 15.9436 10.0784 15.6137 9.41631 15.0535C8.75424 14.4933 8.29217 13.7332 8.09972 12.8876C7.90728 12.042 7.99489 11.1567 8.34934 10.3652C8.7038 9.57374 9.3059 8.91887 10.0649 8.4993C10.824 8.07974 11.6988 7.91819 12.5576 8.03902C13.9223 8.23101 14.9173 9.23345 16 10M16 10V7M16 10H13"
                    stroke="currentcolor" stroke-width="1.25" stroke-linecap="round" stroke-linejoin="round"></path>
            </svg>
        </button>
        <button onclick="setTransformMode('scale')" id="scaleBtn" title="Scale (S)">
            <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <!-- Corner arrows -->
                <path d="M4 4l4 4M4 4l4-1M4 4l-1 4" stroke="currentColor" stroke-width="2" fill="none" />
                <path d="M20 4l-4 4M20 4l-4-1M20 4l1 4" stroke="currentColor" stroke-width="2" fill="none" />
                <path d="M4 20l4-4M4 20l4 1M4 20l-1-4" stroke="currentColor" stroke-width="2" fill="none" />
                <path d="M20 20l-4-4M20 20l-4 1M20 20l1-4" stroke="currentColor" stroke-width="2" fill="none" />
                <!-- Center dot -->
                <circle cx="12" cy="12" r="1" fill="currentColor" />
            </svg>
        </button>
        <button onclick="deselectObject()" title="Deselect (Esc)">
            <svg viewBox="0 0 24 24">
                <path d="M21 3L3 21M3 3l18 18" />
            </svg>
        </button>
    </div>

    <div class="stats-panel">
        <h3>Scene Statistics</h3>
        <div class="stat-item">
            <span class="stat-label">Objects:</span>
            <span class="stat-value" id="objectCount">0</span>
        </div>
        <div class="stat-item">
            <span class="stat-label">Vertices:</span>
            <span class="stat-value" id="vertexCount">0</span>
        </div>
        <div class="stat-item">
            <span class="stat-label">Faces:</span>
            <span class="stat-value" id="faceCount">0</span>
        </div>
    </div>
    <div class="popup-overlay" id="itemPopup" style="display: none;">
        <div class="popup-content">
            <button class="close-button" onclick="closeItemPopup()">×</button>
            <input type="text" class="search-input" id="itemSearch" placeholder="Search items..."
                oninput="filterItems()">
            <div class="grid-container" id="itemGrid">
            </div>
        </div>
    </div>
    <div id="canvas-container"></div>
    <script src="https://cdn.jsdelivr.net/npm/protobufjs@6.11.2/dist/protobuf.min.js"></script>


    <script src="https://cdn.jsdelivr.net/npm/three@latest/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@latest/examples/js/controls/TransformControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@latest/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@latest/examples/js/loaders/OBJLoader.js"></script>

    <script src="./SGALoader.js"></script>

    <script src="./sgmLoader.js"></script>
    <script src="./MeshUtils.js"></script>
    <script src="./Player.js"></script>
    <script src="./levelLoader.js"></script>

    <script>
        let scene, camera, renderer, controls, transformControls;
        let selectedObjects = [];
        let selectionGroup = null;
        let currentMode = 'translate';
        let isOrbiting = false;
        let ableToSelect = true;
        let isMouseDown = false;
        let isTransforming = false;

        let dragStartX, dragStartY;
        let ignoreNextClick = false;
        const DRAG_THRESHOLD = 5; // pixels


        let characterPreviewRenderer;
        let characterPreviewScene;
        let characterPreviewCamera;
        let currentPlayer;
        let currentCategory = 'head';
        let animationFrameId = null; // Track animation frame


        /*the items list stuff*/
        let itemScenes = [];
        let previewScenes = [];
        let previewRenderer = null;
        let isPopupOpen = false;
        let populateTimeoutIds = [];
        let isRenderingPreviews = false;
        let previewRenderRequestId = null;
        const visiblePreviews = new Set();

        let selectionBox;
        let selectionHelper;

        // Controls Variables
        const keyStates = { w: false, a: false, s: false, d: false, q: false, e: false, shift: false, c: false };
        let isRotatingCamera = false;
        let cameraYaw = 0;
        let cameraPitch = 0;
        const cameraRotationSpeed = 0.01;
        const clock = new THREE.Clock();

        let itemsList;
        const element = document.getElementById('tools');
        let isDraggingControls = false;
        let offsetX, offsetY;

        element.addEventListener('mousedown', (e) => {
            if (isPopupOpen) return; // Block dragging when popup is open
            isDraggingControls = true;
            offsetX = e.clientX - element.offsetLeft;
            offsetY = e.clientY - element.offsetTop;
            element.style.cursor = 'grabbing';
        });

        document.addEventListener('mousemove', (e) => {
            if (!isDraggingControls) return;
            const x = e.clientX - offsetX;
            const y = e.clientY - offsetY;
            element.style.left = `${x}px`;
            element.style.top = `${y}px`;
        });

        document.addEventListener('mouseup', () => {
            isDraggingControls = false;
            element.style.cursor = 'grab';
        });
        async function getShopItemsRequest(server) {
            const response = await fetch(server + 'get_shop_items?version=3');
            if (response.status !== 200) {
                return false;
            }

            const responseData = await response.json();

            return Object.fromEntries(
                Object.entries(responseData).reverse()
            );
        }

        const dualSlots = {
            'hand': ['hand/left', 'hand/right'],
            'rope': ['rope/left', 'rope/right'],
            'body/badge': ['body/badge/left', 'body/badge/right'],
            'grapple/hook': ['grapple/hook/left', 'grapple/hook/right']
        };
        function openCharacterEditor(originalPlayer, isNew = false) {
            characterPreviewScene = isNew ? originalPlayer.scene : new THREE.Scene();

            currentPlayer = isNew ? originalPlayer : clonePlayer(originalPlayer, characterPreviewScene);

            initCharacterPreview(currentPlayer);
            populateEquipmentGrid(currentCategory);
            document.getElementById("characterPopup").style.display = "flex";
        }
        function clonePlayer(originalPlayer, targetScene) {
            const playerItems = extractPlayerItems(originalPlayer);
            const colors = {
                primary: originalPlayer.scene.userData[originalPlayer.userInput].primary_color.clone(),
                secondary: originalPlayer.scene.userData[originalPlayer.userInput].secondary_color.clone()
            };

            const clonedPlayer = new Player(targetScene, originalPlayer.itemsList, playerItems, `${originalPlayer.userInput}_preview`);
            clonedPlayer.scene.userData[clonedPlayer.userInput] = {
                primary_color: colors.primary,
                secondary_color: colors.secondary
            };
            return clonedPlayer;
        }

        function extractPlayerItems(player) {
            const playerItems = {};
            Object.entries(player.activeModels).forEach(([type, model]) => {
                const baseType = type.split('/')[0];
                if (dualSlots[baseType]?.includes(type)) {
                    if (!playerItems[baseType]) playerItems[baseType] = model.name;
                } else {
                    playerItems[type] = model.name;
                }
            });
            return playerItems;
        }

        function closeCharacterPopup() {
            document.getElementById("characterPopup").style.display = "none";
            cleanupCharacterPreview();
            cleanupEquipmentPreviews();

            if (currentPlayer && isNewPlayer) {
                currentPlayer.dispose();
                currentPlayer = null;
            }
        }

        function initCharacterPreview(previewPlayer) {
            const aspect = 1;
            characterPreviewCamera = new THREE.PerspectiveCamera(45, aspect, 0.1, 1000);
            characterPreviewCamera.position.set(0, 0, -5);


            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            previewPlayer.scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
            directionalLight.position.set(1, 1, 1);
            previewPlayer.scene.add(directionalLight);

            const playerRoot = previewPlayer.activeModels['body'] ||
                Object.values(previewPlayer.activeModels)[0];

            characterPreviewCamera.lookAt(new THREE.Vector3(0, playerRoot.y, 0))
            characterPreviewRenderer = new THREE.WebGLRenderer({
                canvas: document.getElementById("playerPreviewCanvas"),
                antialias: true,
                alpha: true
            });
            characterPreviewRenderer.setSize(600, 600);

            animateCharacterPreview();
        }

        function animateCharacterPreview() {
            characterPreviewRenderer.render(characterPreviewScene, characterPreviewCamera);

            animationFrameId = requestAnimationFrame(animateCharacterPreview);
        }
        function cleanupCharacterPreview() {
            // Stop animation loop
            if (animationFrameId !== null) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }

            if (characterPreviewRenderer) {
                characterPreviewRenderer.dispose();
                characterPreviewRenderer = null;
            }

            if (characterPreviewScene) {
                while (characterPreviewScene.children.length > 0) {
                    characterPreviewScene.remove(characterPreviewScene.children[0]);
                }
                characterPreviewScene = null;
            }
            characterPreviewCamera = null;
        }

        async function populateEquipmentGrid(category) {
            const grid = document.getElementById("equipmentGrid");
            grid.innerHTML = '';

            const categoryItems = Object.entries(itemsList).filter(([_, item]) =>
                item.type?.startsWith(category)
            );

            categoryItems.forEach(([itemName, itemData]) => {
                const itemDiv = document.createElement('div');
                itemDiv.className = 'grid-item';
                const previewDiv = document.createElement('div');
                previewDiv.className = 'item-preview';
                itemDiv.appendChild(previewDiv);

                const buttonsDiv = document.createElement('div');
                buttonsDiv.style.display = 'flex';
                buttonsDiv.style.gap = '5px';

                if (itemData.supportsSides) {
                    ['left', 'right'].forEach(side => {
                        const fullType = `${itemData.type}/${side}`;
                        const isEquipped = currentPlayer.activeModels[fullType]?.name === itemName;
                        const button = document.createElement('button');
                        button.textContent = isEquipped ? 'Unequip' : `Equip ${side}`;
                        button.onclick = (event) => toggleEquipment(itemName, itemData, fullType, isEquipped, event);
                        buttonsDiv.appendChild(button);
                    });
                } else {
                    const isEquipped = currentPlayer.activeModels[itemData.type]?.name === itemName;
                    const button = document.createElement('button');
                    button.textContent = isEquipped ? 'Unequip' : 'Equip';
                    button.onclick = (event) => toggleEquipment(itemName, itemData, itemData.type, isEquipped, event);
                    buttonsDiv.appendChild(button);
                }

                itemDiv.appendChild(buttonsDiv);
                grid.appendChild(itemDiv);
                loadItemPreview(previewDiv, itemData);
            });
        }
        async function toggleEquipment(itemName, itemData, equipType, isEquipped, event) {
            const element = event.target;
            if (isEquipped || element.textContent === 'Unequip') {
                await currentPlayer.unequip(equipType);
                element.textContent = 'Equip';
            } else {
                await currentPlayer.loadModel(itemName, equipType);
                element.textContent = 'Unequip';
            }
            MeshUtils.applyColorsToAll(currentPlayer);
        }
        function onDone() {
            if (isNewPlayer) {
                const mainPlayer = clonePlayer(currentPlayer, mainScene);
                mainPlayer.userInput = mainPlayer.userInput.replace('_preview', '');
                scene.add(mainPlayer)
            } else {
                applyPlayerChanges(originalPlayer, currentPlayer);
            }
            closeCharacterPopup();
        }
        function applyPlayerChanges(originalPlayer, previewPlayer) {
            originalPlayer.scene.userData[originalPlayer.userInput].primary_color.copy(
                previewPlayer.scene.userData[previewPlayer.userInput].primary_color
            );
            originalPlayer.scene.userData[originalPlayer.userInput].secondary_color.copy(
                previewPlayer.scene.userData[previewPlayer.userInput].secondary_color
            );

            const playerItems = extractPlayerItems(previewPlayer);
            originalPlayer.unequipAll().then(() => {
                Object.entries(playerItems).forEach(([type, itemName]) => {
                    if (dualSlots[type]) {
                        dualSlots[type].forEach(slot => originalPlayer.loadModel(itemName, slot));
                    } else {
                        originalPlayer.loadModel(itemName, type);
                    }
                });
            });
        }


        function changeCategory(category) {
            currentCategory = category;
            document.querySelectorAll('.tab').forEach(tab =>
                tab.classList.toggle('active', tab.textContent === category)
            );
            populateEquipmentGrid(category);
        }

        function equipItem(itemName, type) {
            const itemData = itemsList[itemName];
            currentPlayer.loadModel(itemName, type);
        }

        function applyColors() {
            const primary = document.getElementById("primaryColor").value;
            const secondary = document.getElementById("secondaryColor").value;

            currentPlayer.scene.userData[currentPlayer.userInput].primary_color = new THREE.Color(primary);
            currentPlayer.scene.userData[currentPlayer.userInput].secondary_color = new THREE.Color(secondary);

            MeshUtils.applyColorsToAll(currentPlayer);
            initCharacterPreview();
        }
        function loadItemPreview(container, itemData) {
            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(20, 1, 0.1, 1000);
            camera.position.z = 2;

            scene.add(new THREE.AmbientLight(0xffffff, 0.5));
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
            directionalLight.position.set(1, 1, 1);
            scene.add(directionalLight);

            const renderer = new THREE.WebGLRenderer({ alpha: true });
            renderer.setSize(100, 100);
            container.appendChild(renderer.domElement);

            const sgmLoader = new SGMLoader();
            sgmLoader.load(itemData.file, ({ group }) => {
                let model = MeshUtils.applyMaterialIndices(group, itemData);
                model = MeshUtils.applyNormalColors(itemData, model);

                const bbox = new THREE.Box3().setFromObject(model);
                const size = new THREE.Vector3();
                bbox.getSize(size);

                const center = new THREE.Vector3();
                bbox.getCenter(center);
                model.position.sub(center);

                const maxDim = Math.max(size.x, size.y, size.z);
                const fov = camera.fov * (Math.PI / 180);
                const distance = (maxDim / 2) / Math.tan(fov / 2) * 1.1;

                camera.position.z = distance;
                camera.lookAt(scene.position);

                model = applyPreviewRotation(model, itemData);
                scene.add(model);


                model = applyPreviewRotation(model, itemData);

                scene.add(model);

                const animate = () => {
                    requestAnimationFrame(animate);
                    renderer.render(scene, camera);
                };
                animate();
            });

            container._cleanup = () => {
                renderer.dispose();
                container.removeChild(renderer.domElement);
            };
        }

        function cleanupEquipmentPreviews() {
            document.querySelectorAll('.item-preview').forEach(container => {
                if (container._cleanup) container._cleanup();
            });
        }



        function showEditButton(playerName) {
            const editBtn = document.createElement('button');
            editBtn.textContent = 'Edit Player';
            editBtn.style.position = 'absolute';
            editBtn.style.left = `${event.clientX}px`;
            editBtn.style.top = `${event.clientY}px`;
            editBtn.onclick = () => {
                const player = getPlayerByName(playerName);
                openCharacterEditor(player);
                editBtn.remove();
            };
            document.body.appendChild(editBtn);
        }
        async function createNewPlayer() {
            if (!itemsList || itemsList.length === 0) {
                itemsList = await getShopItemsRequest('https://api.slin.dev/grab/v1/');
            }
            const tempScene = new THREE.Scene();
            const newPlayer = new Player(tempScene, itemsList);
            await newPlayer.initialized;

            openCharacterEditor(newPlayer, true);
        }

        class SelectionHelper {

            constructor(renderer, cssClassName) {
                this.element = document.createElement('div');
                this.element.classList.add(cssClassName);
                this.element.style.pointerEvents = 'none';
                this.element.style.zIndex = '1001';

                this.renderer = renderer;

                this.startPoint = new THREE.Vector2();
                this.pointTopLeft = new THREE.Vector2();
                this.pointBottomRight = new THREE.Vector2();

                this.isDown = false;
                this.enabled = true;

                this.onPointerDown = function (event) {
                    if (this.enabled === false || isTransforming || isPopupOpen || event.button !== 0) return;
                    this.isDown = true;
                    this.onSelectStart(event);
                }.bind(this);

                this.onPointerMove = function (event) {

                    if (this.enabled === false || isPopupOpen) return;

                    if (this.isDown) {

                        this.onSelectMove(event);

                    }

                }.bind(this);

                this.onPointerUp = function (event) {

                    if (this.enabled === false || isPopupOpen || event.button !== 0) return;

                    this.isDown = false;
                    this.onSelectOver();

                }.bind(this);

                this.renderer.domElement.addEventListener('pointerdown', this.onPointerDown);
                this.renderer.domElement.addEventListener('pointermove', this.onPointerMove);
                this.renderer.domElement.addEventListener('pointerup', this.onPointerUp);

            }

            dispose() {

                this.renderer.domElement.removeEventListener('pointerdown', this.onPointerDown);
                this.renderer.domElement.removeEventListener('pointermove', this.onPointerMove);
                this.renderer.domElement.removeEventListener('pointerup', this.onPointerUp);

            }

            onSelectStart(event) {

                this.element.style.display = 'none';

                this.renderer.domElement.parentElement.appendChild(this.element);

                this.element.style.left = event.clientX + 'px';
                this.element.style.top = event.clientY + 'px';
                this.element.style.width = '0px';
                this.element.style.height = '0px';

                this.startPoint.x = event.clientX;
                this.startPoint.y = event.clientY;

            }

            onSelectMove(event) {

                this.element.style.display = 'block';

                this.pointBottomRight.x = Math.max(this.startPoint.x, event.clientX);
                this.pointBottomRight.y = Math.max(this.startPoint.y, event.clientY);
                this.pointTopLeft.x = Math.min(this.startPoint.x, event.clientX);
                this.pointTopLeft.y = Math.min(this.startPoint.y, event.clientY);

                this.element.style.left = this.pointTopLeft.x + 'px';
                this.element.style.top = this.pointTopLeft.y + 'px';
                this.element.style.width = (this.pointBottomRight.x - this.pointTopLeft.x) + 'px';
                this.element.style.height = (this.pointBottomRight.y - this.pointTopLeft.y) + 'px';

            }

            onSelectOver(event) {


                this.element.parentElement.removeChild(this.element);

            }

        }


        const _frustum = new THREE.Frustum();
        const _center = new THREE.Vector3();

        const _tmpPoint = new THREE.Vector3();

        const _vecNear = new THREE.Vector3();
        const _vecTopLeft = new THREE.Vector3();
        const _vecTopRight = new THREE.Vector3();
        const _vecDownRight = new THREE.Vector3();
        const _vecDownLeft = new THREE.Vector3();

        const _vecFarTopLeft = new THREE.Vector3();
        const _vecFarTopRight = new THREE.Vector3();
        const _vecFarDownRight = new THREE.Vector3();
        const _vecFarDownLeft = new THREE.Vector3();

        const _vectemp1 = new THREE.Vector3();
        const _vectemp2 = new THREE.Vector3();
        const _vectemp3 = new THREE.Vector3();

        const _matrix = new THREE.Matrix4();
        const _quaternion = new THREE.Quaternion();
        const _scale = new THREE.Vector3();

        class SelectionBox {

            constructor(camera, scene, deep = Number.MAX_VALUE) {

                this.camera = camera;
                this.scene = scene;
                this.startPoint = new THREE.Vector3();
                this.endPoint = new THREE.Vector3();
                this.collection = [];
                this.instances = {};
                this.deep = deep;

            }

            select(startPoint, endPoint) {

                this.startPoint = startPoint || this.startPoint;
                this.endPoint = endPoint || this.endPoint;
                this.collection = [];

                this.updateFrustum(this.startPoint, this.endPoint);
                this.searchChildInFrustum(_frustum, this.scene);

                return this.collection;
            }

            updateFrustum(startPoint, endPoint) {

                startPoint = startPoint || this.startPoint;
                endPoint = endPoint || this.endPoint;

                // Avoid invalid frustum

                if (startPoint.x === endPoint.x) {

                    endPoint.x += Number.EPSILON;

                }

                if (startPoint.y === endPoint.y) {

                    endPoint.y += Number.EPSILON;

                }

                this.camera.updateProjectionMatrix();
                this.camera.updateMatrixWorld();

                if (this.camera.isPerspectiveCamera) {

                    _tmpPoint.copy(startPoint);
                    _tmpPoint.x = Math.min(startPoint.x, endPoint.x);
                    _tmpPoint.y = Math.max(startPoint.y, endPoint.y);
                    endPoint.x = Math.max(startPoint.x, endPoint.x);
                    endPoint.y = Math.min(startPoint.y, endPoint.y);

                    _vecNear.setFromMatrixPosition(this.camera.matrixWorld);
                    _vecTopLeft.copy(_tmpPoint);
                    _vecTopRight.set(endPoint.x, _tmpPoint.y, 0);
                    _vecDownRight.copy(endPoint);
                    _vecDownLeft.set(_tmpPoint.x, endPoint.y, 0);

                    _vecTopLeft.unproject(this.camera);
                    _vecTopRight.unproject(this.camera);
                    _vecDownRight.unproject(this.camera);
                    _vecDownLeft.unproject(this.camera);

                    _vectemp1.copy(_vecTopLeft).sub(_vecNear);
                    _vectemp2.copy(_vecTopRight).sub(_vecNear);
                    _vectemp3.copy(_vecDownRight).sub(_vecNear);
                    _vectemp1.normalize();
                    _vectemp2.normalize();
                    _vectemp3.normalize();

                    _vectemp1.multiplyScalar(this.deep);
                    _vectemp2.multiplyScalar(this.deep);
                    _vectemp3.multiplyScalar(this.deep);
                    _vectemp1.add(_vecNear);
                    _vectemp2.add(_vecNear);
                    _vectemp3.add(_vecNear);

                    const planes = _frustum.planes;

                    planes[0].setFromCoplanarPoints(_vecNear, _vecTopLeft, _vecTopRight);
                    planes[1].setFromCoplanarPoints(_vecNear, _vecTopRight, _vecDownRight);
                    planes[2].setFromCoplanarPoints(_vecDownRight, _vecDownLeft, _vecNear);
                    planes[3].setFromCoplanarPoints(_vecDownLeft, _vecTopLeft, _vecNear);
                    planes[4].setFromCoplanarPoints(_vecTopRight, _vecDownRight, _vecDownLeft);
                    planes[5].setFromCoplanarPoints(_vectemp3, _vectemp2, _vectemp1);
                    planes[5].normal.multiplyScalar(- 1);

                } else if (this.camera.isOrthographicCamera) {

                    const left = Math.min(startPoint.x, endPoint.x);
                    const top = Math.max(startPoint.y, endPoint.y);
                    const right = Math.max(startPoint.x, endPoint.x);
                    const down = Math.min(startPoint.y, endPoint.y);

                    _vecTopLeft.set(left, top, - 1);
                    _vecTopRight.set(right, top, - 1);
                    _vecDownRight.set(right, down, - 1);
                    _vecDownLeft.set(left, down, - 1);

                    _vecFarTopLeft.set(left, top, 1);
                    _vecFarTopRight.set(right, top, 1);
                    _vecFarDownRight.set(right, down, 1);
                    _vecFarDownLeft.set(left, down, 1);

                    _vecTopLeft.unproject(this.camera);
                    _vecTopRight.unproject(this.camera);
                    _vecDownRight.unproject(this.camera);
                    _vecDownLeft.unproject(this.camera);

                    _vecFarTopLeft.unproject(this.camera);
                    _vecFarTopRight.unproject(this.camera);
                    _vecFarDownRight.unproject(this.camera);
                    _vecFarDownLeft.unproject(this.camera);

                    const planes = _frustum.planes;

                    planes[0].setFromCoplanarPoints(_vecTopLeft, _vecFarTopLeft, _vecFarTopRight);
                    planes[1].setFromCoplanarPoints(_vecTopRight, _vecFarTopRight, _vecFarDownRight);
                    planes[2].setFromCoplanarPoints(_vecFarDownRight, _vecFarDownLeft, _vecDownLeft);
                    planes[3].setFromCoplanarPoints(_vecFarDownLeft, _vecFarTopLeft, _vecTopLeft);
                    planes[4].setFromCoplanarPoints(_vecTopRight, _vecDownRight, _vecDownLeft);
                    planes[5].setFromCoplanarPoints(_vecFarDownRight, _vecFarTopRight, _vecFarTopLeft);
                    planes[5].normal.multiplyScalar(- 1);

                } else {

                    console.error('THREE.SelectionBox: Unsupported camera type.');

                }

            }

            searchChildInFrustum(frustum, object) {
                if (object.isMesh || object.isLine || object.isPoints) {
                    if (object.isInstancedMesh) {
                        this.instances[object.uuid] = [];
                        if (object.geometry.boundingBox === null) {
                            object.geometry.computeBoundingBox();
                        }
                        const geometryBBox = object.geometry.boundingBox.clone();
                        for (let i = 0; i < object.count; i++) {
                            object.getMatrixAt(i, _matrix);
                            const instanceWorldMatrix = new THREE.Matrix4()
                                .multiplyMatrices(object.matrixWorld, _matrix);
                            const instanceWorldBBox = geometryBBox.clone()
                                .applyMatrix4(instanceWorldMatrix);
                            if (frustum.intersectsBox(instanceWorldBBox)) {
                                this.instances[object.uuid].push(i);
                            }
                        }
                    } else {
                        if (object.geometry.boundingBox === null) {
                            object.geometry.computeBoundingBox();
                        }
                        const worldBBox = object.geometry.boundingBox.clone()
                            .applyMatrix4(object.matrixWorld);
                        if (frustum.intersectsBox(worldBBox)) {
                            this.collection.push(object);
                        }
                    }
                }
                if (object.children.length > 0) {
                    for (const child of object.children) {
                        this.searchChildInFrustum(frustum, child);
                    }
                }
            }

        }


        function addPlayer() {
            isPopupOpen = true;
            const popup = document.createElement('div');
            popup.style.position = 'fixed';
            popup.style.top = '50%';
            popup.style.left = '50%';
            popup.style.transform = 'translate(-50%, -50%)';
            popup.style.backgroundColor = '#fff';
            popup.style.padding = '20px';
            popup.style.boxShadow = '0 4px 8px rgba(0, 0, 0, 0.2)';
            popup.style.zIndex = '1000';
            popup.style.borderRadius = '8px';

            const inputField = document.createElement('input');
            inputField.type = 'text';
            inputField.placeholder = 'Enter a username...';
            inputField.style.width = '100%';
            inputField.style.marginBottom = '10px';
            inputField.style.padding = '8px';
            inputField.style.borderRadius = '4px';
            inputField.style.border = '1px solid #ddd';

            const submitButton = document.createElement('button');
            submitButton.textContent = 'Submit';
            submitButton.style.padding = '8px 16px';
            submitButton.style.backgroundColor = '#007bff';
            submitButton.style.color = '#fff';
            submitButton.style.border = 'none';
            submitButton.style.borderRadius = '4px';
            submitButton.style.cursor = 'pointer';

            const cancelButton = document.createElement('button');
            cancelButton.textContent = 'Cancel';
            cancelButton.style.marginLeft = '10px';
            cancelButton.style.padding = '8px 16px';
            cancelButton.style.backgroundColor = '#dc3545';
            cancelButton.style.color = '#fff';
            cancelButton.style.border = 'none';
            cancelButton.style.borderRadius = '4px';
            cancelButton.style.cursor = 'pointer';

            popup.appendChild(inputField);
            popup.appendChild(submitButton);
            popup.appendChild(cancelButton);
            document.body.appendChild(popup);


            submitButton.addEventListener('click', handleSubmit);
            inputField.addEventListener('keydown', (event) => {
                if (event.key === 'Enter') {
                    handleSubmit();
                }
            });

            function handleSubmit() {
                const userInput = inputField.value;
                if (userInput.trim() === '') {
                    alert('Please enter a user before submitting.');
                    return;
                }

                fetch(`https://api.slin.dev/grab/v1/list?max_format_version=10&type=user_name&search_term=${userInput}`)
                    .then(response => response.json())
                    .then(async (data) => {
                        if (data.length > 0) {
                            try {
                                const user = getPlayerSearch(data, userInput);
                                const userInfo = await getUserInfo(user.user_id);
                                if (!itemsList || itemsList.length === 0) {
                                    itemsList = await getShopItemsRequest('https://api.slin.dev/grab/v1/');
                                }
                                scene.userData[userInput] = {}
                                scene.userData[userInput].primary_color = userInfo.active_customizations.player_color_primary.color
                                scene.userData[userInput].secondary_color = userInfo.active_customizations.player_color_secondary.color

                                new Player(scene, itemsList, userInfo.active_customizations.items, userInput);

                                // Reset selections and controls
                                selectedObjects = [];
                                updateTransformControls();
                                updateStats();

                            } catch (error) {
                                console.error("Failed to fetch user info:", error);
                            }
                        } else {
                            console.error("No data found for the search term.");
                        }
                    })
                    .catch(error => {
                        console.error("Failed to fetch user list:", error);
                    });

                isPopupOpen = false;
                document.body.removeChild(popup);
            }
            cancelButton.addEventListener('click', () => {
                document.body.removeChild(popup);
                isPopupOpen = false;
            });

        }
        function getPlayerSearch(searchData, query) {
            if (searchData.length >= 1) {
                // exact match
                for (let result of searchData) {
                    if (result.user_name == query) {
                        return result;
                    }
                }
                // case insensitive match
                for (let result of searchData) {
                    if (result.user_name.toLowerCase() == query.toLowerCase()) {
                        return result;
                    }
                }
                // admin
                for (let result of searchData) {
                    if (result.is_admin) {
                        return result;
                    }
                }
                // supermoderator
                for (let result of searchData) {
                    if (result.is_supermoderator) {
                        return result;
                    }
                }
                // is_moderator
                for (let result of searchData) {
                    if (result.is_moderator) {
                        return result;
                    }
                }
                // verifier
                for (let result of searchData) {
                    if (result.is_verifier) {
                        return result;
                    }
                }
                // creator
                for (let result of searchData) {
                    if (result.is_creator) {
                        return result;
                    }
                }
                // first
                return searchData[0];
            }
            return false;
        }
        async function getUserInfo(user_id) {
            try {
                const getUserInfo = await fetch(`https://api.slin.dev/grab/v1/get_user_info?user_id=${user_id}`);
                const response = await getUserInfo.json();
                return response;
            } catch (error) {
                console.error("Error fetching user info:", error);
                throw error;
            }
        }


        function addItem() {
            if (isPopupOpen) return;
            isPopupOpen = true;
            selectedObjects = [];
            updateTransformControls();
            document.getElementById("itemPopup").style.display = "flex";
            populateItemGrid().then(() => {
                initPreviewRenderer();
                renderPreviewScenes();
            });
        }

        window.addEventListener('resize', () => {
            if (previewRenderer) {
                previewRenderer.setSize(window.innerWidth, window.innerHeight);
            }
            previewScenes.forEach(({ camera }) => {
                camera.aspect = 200 / 84;
                camera.updateProjectionMatrix();
            });
        });

        function closeItemPopup() {
            if (!isPopupOpen) return;
            isPopupOpen = false;

            populateTimeoutIds.forEach(clearTimeout);
            populateTimeoutIds = [];

            document.getElementById("itemPopup").style.display = "none";
            cleanupPreviewScenes();

            if (previewRenderer) {
                cancelAnimationFrame(previewRenderRequestId);
                previewRenderer.domElement.remove();
                previewRenderer.dispose();
                previewRenderer.forceContextLoss();
                previewRenderer = null;
            }
        }

        function initPreviewRenderer() {
            if (!previewRenderer) {
                previewRenderer = new THREE.WebGLRenderer({
                    antialias: true,
                    alpha: true
                });
                previewRenderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                previewRenderer.setSize(window.innerWidth, window.innerHeight);
                document.body.appendChild(previewRenderer.domElement);
                previewRenderer.domElement.style.position = 'fixed';
                previewRenderer.domElement.style.pointerEvents = 'none';
                previewRenderer.domElement.style.zIndex = '1001';
            }
        }

        function applyPreviewRotation(model, itemData) {
            if (itemData.preview_rotation) {
                model.rotation.set(0, 0, 0);
                const [rx, ry, rz] = itemData.preview_rotation.map(Number);
                model.rotation.set(
                    ry * (Math.PI / 180),
                    rx * (Math.PI / 180),
                    rz * (Math.PI / 180)
                );
            }
            return model;
        }
        async function populateItemGrid() {
            const grid = document.getElementById("itemGrid");
            grid.innerHTML = '';

            if (!itemsList || itemsList.length === 0) {
                itemsList = await getShopItemsRequest('https://api.slin.dev/grab/v1/')
            }

            Object.entries(itemsList).forEach(([itemName, itemData], index) => {
                const timeoutId = setTimeout(() => {
                    const itemDiv = document.createElement('div');
                    itemDiv.className = 'grid-item-2';
                    itemDiv.innerHTML = `
                <h4>${itemData.title}</h4>
                <div class="preview-container">
                    <div class="preview-scene"></div>
                </div>
                <button class="add-button" onclick="addItemToScene('${itemName}')">Add</button>
            `;
                    grid.appendChild(itemDiv);
                    setupPreviewScene(itemDiv.querySelector('.preview-scene'), itemData);
                }, index * 100);

                populateTimeoutIds.push(timeoutId);
            });
        }
        function setupPreviewScene(container, itemData) {
            const existingScene = previewScenes.find(s => s.itemData === itemData);
            if (existingScene) {
                cleanupScene(existingScene);
                previewScenes = previewScenes.filter(s => s !== existingScene);
            }

            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(20, 200 / 84, 1, 5000);
            camera.position.z = 2;

            scene.add(new THREE.AmbientLight(0xffffff, 0.5));
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
            directionalLight.position.set(1, 1, 1);
            scene.add(directionalLight);

            if (!itemData.previewModel) {
                itemData.mixer = null;
                itemData.animAction = null;

                const sgmLoader = new SGMLoader();
                sgmLoader.load(itemData.file, (result) => {
                    const modelGroup = result.group.clone();
                    const processedModel = MeshUtils.applyMaterialIndices(modelGroup, itemData);
                    const finalModel = applyPreviewRotation(processedModel, itemData);

                    itemData.previewModel = finalModel;



                    let skinnedMesh;
                    finalModel.traverse(child => {
                        if (child instanceof THREE.SkinnedMesh) {
                            skinnedMesh = child;
                            child.bind(result.skeleton);
                        }
                    });

                    if (skinnedMesh && result.clips.length > 0) {
                        itemData.mixer = new THREE.AnimationMixer(skinnedMesh);

                        result.clips.forEach(clip => {
                            const action = itemData.mixer.clipAction(clip);
                            action.setLoop(THREE.LoopRepeat, Infinity);
                            action.clampWhenFinished = false;
                            action.play();
                        });
                    }

                    const bbox = new THREE.Box3().setFromObject(modelGroup);
                    const size = new THREE.Vector3();
                    bbox.getSize(size);

                    const center = new THREE.Vector3();
                    bbox.getCenter(center);
                    modelGroup.position.sub(center);

                    const maxDim = Math.max(size.x, size.y, size.z);
                    const fov = camera.fov * (Math.PI / 180);
                    const distance = (maxDim / 2) / Math.tan(fov / 2) * 1.1;

                    camera.position.z = distance;
                    camera.lookAt(scene.position);


                    scene.add(finalModel);
                });
            } else {
                scene.add(itemData.previewModel.clone());
            }

            previewScenes.push({ scene, camera, container, itemData });
        }

        function cleanupPreviewScenes() {
            previewScenes.forEach(sceneData => {
                sceneData.scene.clear();

                sceneData.scene.traverse(child => {
                    if (child.isMesh) {
                        child.geometry.dispose();
                        if (child.material) {
                            (Array.isArray(child.material) ? child.material : [child.material])
                                .forEach(m => m.dispose());
                        }
                    }
                });

            });

            previewScenes.length = 0;
            visiblePreviews.clear();
        }
        let isRenderingPreview = false;
        let clock2 = new THREE.Clock();

        let activePreviews = new Set();

        function renderPreviewScenes() {
            if (!isPopupOpen || !previewRenderer) return;

            const contentRect = document.querySelector('.popup-content').getBoundingClientRect();
            const delta = clock2.getDelta();

            previewRenderer.setScissorTest(true);
            previewRenderer.clear();

            previewScenes.forEach(({ scene, camera, container, itemData }) => {
                const rect = container.getBoundingClientRect();
                const isVisible = (
                    rect.top <= contentRect.bottom &&
                    rect.bottom >= contentRect.top
                );

                if (isVisible) activePreviews.add(itemData);
                else activePreviews.delete(itemData);

                if (!isVisible) return;

                if (itemData.mixer && activePreviews.has(itemData)) {
                    itemData.mixer.update(delta);
                }

                previewRenderer.setViewport(rect.left, previewRenderer.domElement.height - rect.bottom,
                    rect.width, rect.height);
                previewRenderer.setScissor(rect.left, previewRenderer.domElement.height - rect.bottom,
                    rect.width, rect.height);

                previewRenderer.render(scene, camera);
            });

            previewRenderer.setScissorTest(false);
            previewRenderRequestId = requestAnimationFrame(renderPreviewScenes);
        }

        function cleanupScene(sceneData) {
            sceneData.scene.traverse(child => {
                if (child.isMesh) {
                    child.geometry?.dispose();
                    if (child.material) {
                        (Array.isArray(child.material) ? child.material : [child.material])
                            .forEach(m => m.dispose());
                    }
                }
            });
            sceneData.scene.clear();
        }

        function filterItems() {
            const search = document.getElementById("itemSearch").value.toLowerCase();
            document.querySelectorAll('.grid-item').forEach(item => {
                const title = item.querySelector('h4').textContent.toLowerCase();
                item.style.display = title.includes(search) ? 'block' : 'none';
            });
        }
        let mixer = null;
        function addItemToScene(itemName) {
            const itemData = itemsList[itemName];
            const sgmLoader = new SGMLoader();


            sgmLoader.load(itemData.file, ({ group, skeleton, clips }) => {
                let model = group;
                model = MeshUtils.applyMaterialIndices(model, itemData);
                model = applyPreviewRotation(model, itemData);
                scene.add(model);

                let skinnedMesh;
                group.traverse(child => {
                    if (child instanceof THREE.SkinnedMesh) {
                        skinnedMesh = child;
                        child.bind(skeleton);
                    }
                });

                if (skinnedMesh && clips.length > 0) {
                    mixer = new THREE.AnimationMixer(skinnedMesh);

                    clips.forEach(clip => {
                        const action = mixer.clipAction(clip);
                        action.setLoop(THREE.LoopRepeat, Infinity);
                        action.clampWhenFinished = false;
                        action.play();
                    });
                }

                camera.position.set(2, 2, 5);
                camera.lookAt(group.position);
                closeItemPopup();
            });
        }

        function addLevel() {
            isPopupOpen = true;
            const popup = document.createElement('div');
            popup.style.position = 'fixed';
            popup.style.top = '50%';
            popup.style.left = '50%';
            popup.style.transform = 'translate(-50%, -50%)';
            popup.style.backgroundColor = '#fff';
            popup.style.padding = '20px';
            popup.style.boxShadow = '0 4px 8px rgba(0, 0, 0, 0.2)';
            popup.style.zIndex = '1000';
            popup.style.borderRadius = '8px';

            const inputField = document.createElement('input');
            inputField.type = 'text';
            inputField.placeholder = 'Enter level URL...';
            inputField.style.width = '100%';
            inputField.style.marginBottom = '10px';
            inputField.style.padding = '8px';
            inputField.style.borderRadius = '4px';
            inputField.style.border = '1px solid #ddd';

            const submitButton = document.createElement('button');
            submitButton.textContent = 'Submit';
            submitButton.style.padding = '8px 16px';
            submitButton.style.backgroundColor = '#007bff';
            submitButton.style.color = '#fff';
            submitButton.style.border = 'none';
            submitButton.style.borderRadius = '4px';
            submitButton.style.cursor = 'pointer';

            const cancelButton = document.createElement('button');
            cancelButton.textContent = 'Cancel';
            cancelButton.style.marginLeft = '10px';
            cancelButton.style.padding = '8px 16px';
            cancelButton.style.backgroundColor = '#dc3545';
            cancelButton.style.color = '#fff';
            cancelButton.style.border = 'none';
            cancelButton.style.borderRadius = '4px';
            cancelButton.style.cursor = 'pointer';

            popup.appendChild(inputField);
            popup.appendChild(submitButton);
            popup.appendChild(cancelButton);
            document.body.appendChild(popup);

            submitButton.addEventListener('click', handleSubmit);
            inputField.addEventListener('keydown', (event) => {
                if (event.key === 'Enter') {
                    handleSubmit();
                }
            });

            function handleSubmit() {
                const userInput = inputField.value;
                if (userInput.trim() === '') {
                    alert('Please enter a level URL.');
                    return;
                }

                const levelId = userInput.split('?level=')[1];
                if (levelId) {
                    const formattedLevelId = levelId.replace(':', '/');

                    fetch(`https://api.slin.dev/grab/v1/details/${formattedLevelId}/`)
                        .then(response => response.json())
                        .then(levelDetails => {
                            const iteration = levelDetails.iteration;

                    fetch(`https://api.slin.dev/grab/v1/download/${formattedLevelId}/${iteration}`)
                        .then(response => response.arrayBuffer())
                        .then(levelData => {
                            new LevelLoader(scene).loadLevel(levelData);
                        })
                        .catch(error => console.error('Error fetching level data:', error));
                } else {
                    alert('Invalid URL. Please ensure the URL contains ?level= followed by the level ID.');
                }

                isPopupOpen = false;
                document.body.removeChild(popup);
            }

            cancelButton.addEventListener('click', () => {
                document.body.removeChild(popup);
                isPopupOpen = false;
            });
        }



        const history = { undo: [], redo: [] };


        function handleFileSelection(event) {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.readAsArrayBuffer(file);
                reader.onload = function () {
                    const arrayBuffer = reader.result;
                    const elementID = event.target.id
                    switch (true) {
                        case elementID.includes('sgm'):
                            loadSGM(arrayBuffer);
                            break;
                        case elementID.includes('glb'):
                            loadGLB(arrayBuffer)
                            break;
                        case elementID.includes('obj'):
                            loadOBJ(arrayBuffer)
                            break;

                    }
                };
            }
        }
        function loadSGM(arrayBuffer) {
            const loader = new SGMLoader();
            const result = loader.parse(arrayBuffer);
            const group = loader.createGroupFromMeshes(result[0], result[1]);
            group.isMesh = true;
            group.position.y += 0.2
            scene.add(group);
        }
        function loadGLB(arrayBuffer) {
            const loader = new THREE.GLTFLoader();
            loader.parse(
                arrayBuffer,
                '',
                (gltf) => {
                    const model = gltf.scene;
                    scene.add(model);
                },
                (error) => {
                    console.error('An error happened while parsing GLB:', error);
                }
            );
        }

        function loadOBJ(arrayBuffer) {
            const decoder = new TextDecoder();
            const textContent = decoder.decode(arrayBuffer);
            const loader = new THREE.OBJLoader();
            const obj = loader.parse(textContent);
            obj.isMesh = true;
            obj.position.y += 0.2;
            scene.add(obj);
        }
        function saveState() {
            if (selectedObjects.length > 0) {
                const state = selectedObjects.map(obj => {
                    const worldPos = new THREE.Vector3();
                    const worldRot = new THREE.Quaternion();
                    const worldScale = new THREE.Vector3();
                    obj.updateMatrixWorld();
                    obj.matrixWorld.decompose(worldPos, worldRot, worldScale);

                    const originalParent = obj.parent === activeGroup ? scene : obj.parent;

                    return {
                        object: obj,
                        worldPos: worldPos.clone(),
                        worldRot: worldRot.clone(),
                        worldScale: worldScale.clone(),
                        parent: originalParent,
                        deleted: false
                    };
                });
                history.undo.push(state);
                history.redo = [];
            }
        }
        function handleDelete() {
            if (selectedObjects.length > 0) {
                saveState();

                selectedObjects.forEach(obj => {
                    if (obj.parent) {
                        obj.parent.remove(obj);
                    }
                });

                history.undo[history.undo.length - 1].forEach(objState => objState.deleted = true);

                selectedObjects = [];
                updateTransformControls();
                updateStats();
            }
        } function undoMutation() {
            if (history.undo.length > 0) {
                const state = history.undo.pop();

                history.redo.push(state.map(objState => ({
                    ...objState,
                    worldPos: objState.object.getWorldPosition(new THREE.Vector3()).clone(),
                    worldRot: objState.object.getWorldQuaternion(new THREE.Quaternion()).clone(),
                    worldScale: objState.object.getWorldScale(new THREE.Vector3()).clone()
                })));

                state.forEach(objState => {
                    const obj = objState.object;

                    if (obj.parent) {
                        obj.parent.remove(obj);
                    }

                    objState.parent.add(obj);

                    objState.parent.updateMatrixWorld(true);

                    const parentInverse = new THREE.Matrix4().copy(objState.parent.matrixWorld).invert();

                    const worldMatrix = new THREE.Matrix4().compose(
                        objState.worldPos,
                        objState.worldRot,
                        objState.worldScale
                    );

                    worldMatrix.premultiply(parentInverse);

                    worldMatrix.decompose(obj.position, obj.quaternion, obj.scale);

                    obj.updateMatrix();
                    obj.updateMatrixWorld(true);
                });

                selectedObjects = [];
                updateTransformControls();
                updateStats();
            }
        }

        function redoMutation() {
            if (history.redo.length > 0) {
                const state = history.redo.pop();

                history.undo.push(state.map(objState => ({
                    ...objState,
                    worldPos: objState.object.getWorldPosition(new THREE.Vector3()).clone(),
                    worldRot: objState.object.getWorldQuaternion(new THREE.Quaternion()).clone(),
                    worldScale: objState.object.getWorldScale(new THREE.Vector3()).clone()
                })));

                state.forEach(objState => {
                    const obj = objState.object;

                    if (objState.deleted) {
                        if (scene.children.includes(obj)) {
                            scene.remove(obj);
                        }
                    } else {
                        if (obj.parent) {
                            obj.parent.remove(obj);
                        }
                        objState.parent.add(obj);

                        objState.parent.updateMatrixWorld(true);
                        const parentInverse = new THREE.Matrix4().copy(objState.parent.matrixWorld).invert();

                        const worldMatrix = new THREE.Matrix4().compose(
                            objState.worldPos,
                            objState.worldRot,
                            objState.worldScale
                        );
                        worldMatrix.premultiply(parentInverse);
                        worldMatrix.decompose(obj.position, obj.quaternion, obj.scale);

                        obj.updateMatrix();
                        obj.updateMatrixWorld(true);
                    }
                });

                selectedObjects = [];
                updateTransformControls();
                updateStats();
            }
        }

        function setTransformMode(mode) {
            currentMode = mode;
            transformControls.setMode(mode);
            document.querySelectorAll('.tools button').forEach(btn =>
                btn.classList.remove('active'));
            document.getElementById(`${mode}Btn`).classList.add('active');
        }


        function initThreeJS() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / (window.innerHeight - 50), 0.1, 1000);
            camera.rotation.order = 'YXZ';

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight - 50);

            selectionBox = new SelectionBox(camera, scene);
            selectionHelper = new SelectionHelper(renderer, 'selectBox');

            document.getElementById('canvas-container').appendChild(renderer.domElement);


            const directionalLight = new THREE.DirectionalLight(0xffffff, 2.5);

            const AmbientLight = new THREE.AmbientLight(0xffffff, 1.0);
            scene.add(AmbientLight, directionalLight)

            camera.position.set(5, 5, 5);
            camera.lookAt(0, 0, 0);

            const gridHelper = new THREE.GridHelper(20, 20);
            scene.add(gridHelper);


            transformControls = new THREE.TransformControls(camera, renderer.domElement);
            transformControls.name = 'transformControls'
            scene.add(transformControls);
            let isCtrlPressed = false;

            document.addEventListener('keydown', (event) => {
                if (event.key === 'Control') {
                    isCtrlPressed = true;
                    updateSnapping();
                }
            });

            document.addEventListener('keyup', (event) => {
                if (event.key === 'Control') {
                    isCtrlPressed = false;
                    updateSnapping();
                }
            });

            function updateSnapping() {
                if (isCtrlPressed) {
                    transformControls.setTranslationSnap(1); // Snap to 1 unit increments
                    transformControls.setRotationSnap(Math.PI / 4); // Snap to 45 degree increments
                    transformControls.setScaleSnap(0.1); // Snap to 0.1 scale increments
                } else {
                    // Disable snapping when Ctrl is released
                    transformControls.setTranslationSnap(null);
                    transformControls.setRotationSnap(null);
                    transformControls.setScaleSnap(null);
                }
            }

            transformControls.addEventListener('dragging-changed', event => {
                isTransforming = event.value;
                selectionHelper.enabled = !event.value;

                if (event.value) {
                    ignoreNextClick = true;
                    selectionHelper.onSelectOver();
                    updateSnapping();
                }

                if (event.value) saveState();
            });

            document.addEventListener('keydown', handleKeyDown);
            document.addEventListener('keyup', handleKeyUp);
            renderer.domElement.addEventListener('mousedown', onMouseDown);
            document.addEventListener('mouseup', onMouseUp);
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('contextmenu', (event) => event.preventDefault());


            renderer.domElement.addEventListener('click', onCanvasClick);

            addCube(0, 0.5, 0);
            addCube(0, 2, 0);

            animate();
        }

        function handleKeyDown(event) {
            const isInput = event.target.tagName === 'INPUT' || event.target.tagName === 'TEXTAREA';
            if (isInput || isPopupOpen) return;
            const key = event.key.toLowerCase();
            if (key === 'shift') keyStates.shift = true;

            else if ('wasdqec'.includes(key)) keyStates[key] = true;
        }

        function handleKeyUp(event) {
            const isInput = event.target.tagName === 'INPUT' || event.target.tagName === 'TEXTAREA';
            if (isInput || isPopupOpen) return;
            const key = event.key.toLowerCase();
            if (key === 'shift') keyStates.shift = false;
            else if ('wasdqec'.includes(key)) keyStates[key] = false;
        }

        function onMouseDown(event) {
            if (isPopupOpen) return; // Block rotation
            if (event.button === 2) { // Right-click
                isRotatingCamera = true;
                renderer.domElement.requestPointerLock();
            }
        }

        function onMouseUp(event) {
            if (event.button === 2) {
                isRotatingCamera = false;
                document.exitPointerLock();
            }
        }

        function onMouseMove(event) {
            if (isRotatingCamera && document.pointerLockElement === renderer.domElement) {
                cameraYaw -= event.movementX * cameraRotationSpeed;
                cameraPitch -= event.movementY * cameraRotationSpeed;
                cameraPitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, cameraPitch));
                camera.rotation.set(cameraPitch, cameraYaw, 0, 'YXZ');
            }
        }
        function addCube(x = 0, y = 0.5, z = 0) {
            const geometry = new THREE.BoxGeometry(1, 1, 1);
            const material = new THREE.MeshLambertMaterial({ color: 0x00ff00 });
            const cube = new THREE.Mesh(geometry, material);
            cube.position.set(x, y, z);
            scene.add(cube);
            updateStats();
        }

        let activeGroup = null;
        function updateTransformControls() {
            if (transformControls.object) {
                if (activeGroup) {
                    activeGroup.updateMatrixWorld(true);

                    activeGroup.isActiveGroup = false;
                    const worldPositions = activeGroup.children.map(obj => {
                        const worldPos = new THREE.Vector3();
                        const worldRot = new THREE.Quaternion();
                        const worldScale = new THREE.Vector3();
                        obj.updateMatrixWorld();
                        obj.matrixWorld.decompose(worldPos, worldRot, worldScale);
                        return { obj, worldPos, worldRot, worldScale };
                    });

                    worldPositions.forEach(({ obj, worldPos, worldRot, worldScale }) => {
                        scene.add(obj);
                        obj.position.copy(worldPos);
                        obj.quaternion.copy(worldRot);
                        obj.scale.copy(worldScale);
                        obj.updateMatrix();
                    });

                    scene.remove(activeGroup);
                    activeGroup = null;
                }
                transformControls.detach();
                updatingTransformControls = false;
            }

            if (selectedObjects.length > 0) {
                activeGroup = new THREE.Group();
                activeGroup.isActiveGroup = true;

                const center = new THREE.Vector3();
                selectedObjects.forEach(obj => center.add(obj.position));
                center.divideScalar(selectedObjects.length);
                activeGroup.position.copy(center);

                selectedObjects.forEach(obj => {
                    const localPos = obj.position.clone().sub(center);
                    activeGroup.add(obj);
                    obj.position.copy(localPos);
                    obj.updateMatrix();
                });

                scene.add(activeGroup);
                transformControls.attach(activeGroup);
            }
        }

        function onCanvasClick(event) {
            if (isPopupOpen || event.button !== 0) return;
            if (ignoreNextClick || isTransforming || isPopupOpen || event.button !== 0) {
                ignoreNextClick = false;
                return;
            }

            const rect = renderer.domElement.getBoundingClientRect();
            const mouse = new THREE.Vector2(
                ((event.clientX - rect.left) / rect.width) * 2 - 1,
                -((event.clientY - rect.top) / rect.height) * 2 + 1
            );

            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(mouse, camera);
            const meshObjects = [];
            scene.traverse(obj => {
                if (obj.isMesh && getHighestParent(obj).name !== 'transformControls' && getHighestParent(obj).type !== 'GridHelper') {
                    meshObjects.push(obj);
                }
            });

            const intersects = raycaster.intersectObjects(meshObjects, true);

            if (intersects.length > 0) {
                const object = getHighestParent(intersects[0].object);
                const grabType = object.grab_type;
                const objectPlayer = object.player;
                if (event.shiftKey) {
                    if (selectedObjects.includes(object)) {
                        selectedObjects = selectedObjects.filter(obj => obj !== object);
                    } else {
                        selectedObjects.push(object);
                    }
                } else {
                    const attachments = scene.children.filter(obj =>
                        obj.player === objectPlayer && obj.grab_type?.startsWith(`${grabType}/`)
                    );
                    selectedObjects = [object, ...attachments];
                }
                if (object.player) {
                    showEditButton(object.player);
                }
            } else {
                selectedObjects = [];
            }

            updateTransformControls();
            updateStats();
        }

        function animate() {

            requestAnimationFrame(animate);
            if (!isPopupOpen) {
                const delta = clock.getDelta();

                if (mixer) {
                    mixer.update(delta);
                }

                const direction = new THREE.Vector3();
                camera.getWorldDirection(direction);
                const right = new THREE.Vector3().crossVectors(direction, camera.up).normalize();

                const movement = new THREE.Vector3();
                if (keyStates.w) movement.add(direction);
                if (keyStates.s) movement.sub(direction);
                if (keyStates.a) movement.sub(right);
                if (keyStates.d) movement.add(right);
                if (keyStates.e) movement.add(camera.up);
                if (keyStates.q) movement.sub(camera.up);

                if (movement.length() > 0) {
                    const speedMultiplier = (keyStates.shift ? 32 : 0) + (keyStates.c ? 96 : 0) || 8;
                    movement.normalize().multiplyScalar(speedMultiplier * delta);

                    camera.position.add(movement);
                }

                renderer.render(scene, camera);
                updateStats();
            }
        }
        window.addEventListener('keydown', handleGlobalKeys);
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / (window.innerHeight - 50);
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight - 50);
        });

        function handleGlobalKeys(event) {
            const isInput = event.target.tagName === 'INPUT' || event.target.tagName === 'TEXTAREA';
            if (isPopupOpen && isInput) return; // Ignore if typing in popup
            if (event.ctrlKey) {
                if (event.key === 'z') {
                    undoMutation();
                } else if (event.key === 'y') {
                    redoMutation();
                }
            } else if (event.key === 'Delete' || event.key === 'Backspace') {
                handleDelete();
            }
        }
        let isBoxSelecting = false;


        document.addEventListener('pointerdown', event => {
            if (event.button !== 0 || isPopupOpen || isTransforming) {
                return; // Do not disable selectionHelper here
            };

            dragStartX = event.clientX;
            dragStartY = event.clientY;
            isBoxSelecting = true;
            const rect = renderer.domElement.getBoundingClientRect();
            selectionBox.startPoint.set(
                ((event.clientX - rect.left) / rect.width) * 2 - 1,
                -((event.clientY - rect.top) / rect.height) * 2 + 1,
                0.5
            );
        });

        document.addEventListener('pointermove', event => {
            if (!isBoxSelecting) return;

            const rect = renderer.domElement.getBoundingClientRect();
            selectionBox.endPoint.set(
                ((event.clientX - rect.left) / rect.width) * 2 - 1,
                -((event.clientY - rect.top) / rect.height) * 2 + 1,
                0.5
            );
        });
        document.addEventListener('pointerup', event => {
            if (!isBoxSelecting) return;
            isBoxSelecting = false;
            // Calculate drag distance
            const deltaX = event.clientX - dragStartX;
            const deltaY = event.clientY - dragStartY;
            const dragDistance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
            if (dragDistance > DRAG_THRESHOLD) {
                ignoreNextClick = true;
                const newSelection = selectionBox.select()
                    .map(obj => getHighestParent(obj))
                    .filter(obj => obj.name !== "transformControls" && obj.type !== "GridHelper");
                selectedObjects = [...new Set([...selectedObjects, ...newSelection])];
            }


            updateTransformControls();
            updateStats();
        });



        window.addEventListener('keydown', event => {
            if (!event.ctrlKey && !isPopupOpen) {
                switch (event.key.toLowerCase()) {
                    case 'g':
                        setTransformMode('translate');
                        break;
                    case 'r':
                        setTransformMode('rotate');
                        break;
                    case 's':
                        setTransformMode('scale');
                        break;
                    case 'escape':
                        deselectObject();
                        break;
                }
            }
        });
        function getHighestParent(object) {
            let parent = object;
            while (parent.parent && parent.parent.type !== 'Scene') {
                parent = parent.parent;
            }
            return parent;
        }

        function updateStats() {
            let vertexCount = 0;
            let triangleCount = 0;
            let meshCount = 0;

            scene.traverse(obj => {
                if (obj.isMesh && getHighestParent(obj).name !== 'transformControls' && getHighestParent(obj).type !== 'GridHelper') {
                    meshCount++;
                    const geometry = obj.geometry;

                    if (geometry) {
                        const vertices = geometry.attributes.position.count;
                        const indexCount = geometry.index ? geometry.index.count : 0;

                        vertexCount += vertices;
                        triangleCount += indexCount > 0 ? indexCount / 3 : vertices / 3;
                    }
                }
            });

            document.getElementById('objectCount').textContent = meshCount;
            document.getElementById('vertexCount').textContent = vertexCount;
            document.getElementById('faceCount').textContent = triangleCount;
        }

        initThreeJS();

    </script>
</body>

</html>
